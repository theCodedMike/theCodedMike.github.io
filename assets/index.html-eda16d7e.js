import{_ as o,a as d,b as n,c as l}from"./hash_table_average_insertion_time-4abb6ed9.js";import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as _,c as f,a,d as r,w as i,e as h,b as e}from"./app-23b1e707.js";const u={},g=h('<h2 id="哈希表的理论知识" tabindex="-1"><a class="header-anchor" href="#哈希表的理论知识" aria-hidden="true">#</a> 哈希表的理论知识</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><figure><img src="'+o+'" alt="hash table" tabindex="0" loading="lazy"><figcaption>hash table</figcaption></figure><h3 id="哈希函数" tabindex="-1"><a class="header-anchor" href="#哈希函数" aria-hidden="true">#</a> 哈希函数</h3><p>若关键字为<code>k</code>，则其值存放在<code>f(k)</code>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<code>f</code>为散列函数。</p><p>对不同的关键字可能得到同一散列地址，即<code>k1 != k2</code>，而<code>f(k1) = f(k2)</code>，这种现象称为<strong>冲突</strong>（Collision）。</p><h3 id="处理冲突" tabindex="-1"><a class="header-anchor" href="#处理冲突" aria-hidden="true">#</a> 处理冲突</h3><h4 id="_1-分离连接法" tabindex="-1"><a class="header-anchor" href="#_1-分离连接法" aria-hidden="true">#</a> 1. 分离连接法</h4><figure><img src="'+d+'" alt="separate chaining" tabindex="0" loading="lazy"><figcaption>separate chaining</figcaption></figure><h4 id="_2-开放定址法" tabindex="-1"><a class="header-anchor" href="#_2-开放定址法" aria-hidden="true">#</a> 2. 开放定址法</h4><ul><li><em><strong>线性探测</strong></em>: 逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。<br><img src="'+n+'" alt="linear probing" loading="lazy"></li><li><em><strong>平方探测</strong></em></li><li><em><strong>二次哈希</strong></em></li></ul><h3 id="载荷因子" tabindex="-1"><a class="header-anchor" href="#载荷因子" aria-hidden="true">#</a> 载荷因子</h3><p>散列表的载荷因子定义为：a = 填入表中的元素个数 / 散列表的长度</p><p>a是散列表装满程度的标志因子。由于表长是定值，a与&quot;填入表中的元素个数&quot;成正比，所以，a越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，a越小，表明填入表中的元素越少，产生冲突的可能性就越小。</p><p>对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。</p><figure><img src="'+l+'" alt="load factor" tabindex="0" loading="lazy"><figcaption>load factor</figcaption></figure><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题" aria-hidden="true">#</a> 习题</h2><h3 id="有效的字母异位词" tabindex="-1"><a class="header-anchor" href="#有效的字母异位词" aria-hidden="true">#</a> 有效的字母异位词</h3>',19),m=a("br",null,null,-1),p=a("br",null,null,-1),b=a("br",null,null,-1),x=a("h3",{id:"两个数组的交集",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#两个数组的交集","aria-hidden":"true"},"#"),e(" 两个数组的交集")],-1),z=a("br",null,null,-1),k=a("h3",{id:"快乐数",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#快乐数","aria-hidden":"true"},"#"),e(" 快乐数")],-1),y=h('<h3 id="两数之和" tabindex="-1"><a class="header-anchor" href="#两数之和" aria-hidden="true">#</a> 两数之和</h3><p>[1: 两数之和]</p><h3 id="三数之和" tabindex="-1"><a class="header-anchor" href="#三数之和" aria-hidden="true">#</a> 三数之和</h3><p>[15: 三数之和]<br> [16: 最接近的三数之和]</p><h3 id="四数之和" tabindex="-1"><a class="header-anchor" href="#四数之和" aria-hidden="true">#</a> 四数之和</h3><p>[18: 四数之和]<br> [454: 四数之和II]</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',7);function v(w,I){const t=c("RouterLink");return _(),f("div",null,[g,a("p",null,[r(t,{to:"/zh/algorithm/leetcode/hashtable/242_valid_anagram.html"},{default:i(()=>[e("242: 有效的字母异位词")]),_:1}),m,r(t,{to:"/zh/algorithm/leetcode/hashtable/383_ransom_note.html"},{default:i(()=>[e("383: 赎金信")]),_:1}),p,r(t,{to:"/zh/algorithm/leetcode/hashtable/49_group_anagrams.html"},{default:i(()=>[e("49: 字母异位词分组")]),_:1}),b,r(t,{to:"/zh/algorithm/leetcode/hashtable/438_find_all_anagrams_in_a_string.html"},{default:i(()=>[e("438: 找到字符串中所有字母异位词")]),_:1})]),x,a("p",null,[r(t,{to:"/zh/algorithm/leetcode/hashtable/349_intersection_of_two_arrays.html"},{default:i(()=>[e("349: 两个数组的交集")]),_:1}),z,r(t,{to:"/zh/algorithm/leetcode/hashtable/350_intersection_of_two_arrays_ii.html"},{default:i(()=>[e("350: 两个数组的交集II")]),_:1})]),k,a("p",null,[r(t,{to:"/zh/algorithm/leetcode/hashtable/202_happy_number.html"},{default:i(()=>[e("202: 快乐数")]),_:1})]),y])}const C=s(u,[["render",v],["__file","index.html.vue"]]);export{C as default};
