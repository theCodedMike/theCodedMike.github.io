import{_ as c,a as h,b as u,c as b,d as m,e as p,f,g as v,h as y,i as g}from"./bfs-c672bb62.js";import{_}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as T,c as x,a as e,b as r,d as t,w as n,e as d}from"./app-71745f52.js";const B={},w=e("h2",{id:"binary-tree",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#binary-tree","aria-hidden":"true"},"#"),r(" Binary Tree")],-1),k=e("h3",{id:"definition",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#definition","aria-hidden":"true"},"#"),r(" Definition")],-1),I={href:"https://en.wikipedia.org/wiki/Binary_tree",target:"_blank",rel:"noopener noreferrer"},A=e("strong",null,"binary tree",-1),S=e("code",null,"left child",-1),C=e("code",null,"right child",-1),N={href:"https://en.wikipedia.org/wiki/M-ary_tree",target:"_blank",rel:"noopener noreferrer"},L=e("strong",null,"k-ary tree",-1),D=e("em",null,"recursive definition",-1),F=e("br",null,null,-1),z=e("img",{src:c,alt:"binary_tree",loading:"lazy"},null,-1),E=d('<h3 id="definition-in-graph-theory" tabindex="-1"><a class="header-anchor" href="#definition-in-graph-theory" aria-hidden="true">#</a> Definition in Graph Theory</h3><p>From a graph theory perspective, binary trees as defined here are <strong>arborescences</strong>. A binary tree may thus be also called a <strong>bifurcating arborescence</strong>, a term which appears in some very old programming books before the modern computer science terminology prevailed. It is also possible to interpret a binary tree as an undirected, rather than directed graph, in which case a binary tree is an ordered, rooted tree. Some authors use rooted binary tree instead of binary tree to emphasize the fact that the tree is rooted, but as defined above, a binary tree is always rooted.</p><h3 id="types-of-binary-trees" tabindex="-1"><a class="header-anchor" href="#types-of-binary-trees" aria-hidden="true">#</a> Types of Binary Trees</h3><ol><li><p><strong>Full Binary Tree</strong>: A full binary tree (sometimes referred to as a <strong>proper</strong>, <strong>plane</strong>, or <strong>strict</strong> binary tree) is a tree in which every node has either 0 or 2 children. Another way of defining a full binary tree is a recursive definition. A full binary tree is either:</p><ul><li>A single vertex (a single node as the root node).</li><li>A tree whose root node has two subtrees, both of which are full binary trees.<br><img src="'+u+'" alt="full binary tree" loading="lazy"></li></ul></li><li><p><strong>Perfect Binary Tree</strong>: A perfect binary tree is a binary tree in which all interior nodes have two children and all leaves have the same depth or same level (the level of a node defined as the number of edges or links from the root node to a node). A perfect binary tree is a full binary tree.<br><img src="'+b+'" alt="perfect binary tree" loading="lazy"></p></li><li><p><strong>Complete Binary Tree</strong>: A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes at the last level h. A perfect tree is therefore always complete but a complete tree is not always perfect.<br><img src="'+m+'" alt="complete binary tree, not full binary tree" loading="lazy"></p></li><li><p><strong>Balanced Binary Tree</strong>: A balanced binary tree is a binary tree structure in which the left and right subtrees of every node differ in height (the number of edges from the top-most node to the farthest node in a subtree) by no more than 1.<br><img src="'+p+'" alt="AVL" loading="lazy"></p></li><li><p><strong>Degenerate Tree</strong>: A degenerate (or <strong>pathological</strong>) tree is where each parent node has only one associated child node. This means that the tree will behave like a linked list data structure.<br><img src="'+f+'" alt="degenerate tree" loading="lazy"></p></li></ol><h3 id="properties-of-binary-trees" tabindex="-1"><a class="header-anchor" href="#properties-of-binary-trees" aria-hidden="true">#</a> Properties of Binary Trees</h3><ul><li><p>The number of nodes <code>n</code> in a full binary tree is at least <code>2ℎ + 1</code> and at most <code>2^(ℎ+1) − 1</code> (i.e., the number of nodes in a perfect binary tree), where <code>ℎ</code> is the height of the tree. A tree consisting of only a root node has a height of 0. For a perfect tree, the number of nodes is <code>1 + 2 + 4 + … + 2^ℎ = 2^(ℎ+1) − 1</code>.</p></li><li><p>The number of leaf nodes <code>l</code> in a perfect binary tree is <code>(n + 1) / 2</code> (where <code>n</code> is the number of nodes in the tree).</p></li><li><p>For any non-empty binary tree with <code>l</code> leaf nodes and <code>i2</code> nodes of degree 2 (internal nodes with two child nodes), <code>l = i2 + 1</code>.</p></li><li><p>With given <code>n</code> nodes, the minimum possible tree height is <code>ℎ = log2(n + 1) − 1</code> with which the tree is a balanced full tree or perfect tree.</p></li><li><p>A binary Tree with <code>l</code> leaves has at least the height <code>ℎ = log2(l)</code>.</p></li><li><p>In a non-empty binary tree, if <code>n</code> is the total number of nodes and <code>e</code> is the total number of edges, then <code>e = n − 1</code>.</p></li><li><p>The number of null links (i.e., absent children of the nodes) in a binary tree of <code>n</code> nodes is <code>(n + 1)</code>.</p></li><li><p>The number of internal nodes in a complete binary tree of <code>n</code> nodes is <code>⌊n/2⌋</code>.</p></li></ul><h3 id="operations-of-binary-trees" tabindex="-1"><a class="header-anchor" href="#operations-of-binary-trees" aria-hidden="true">#</a> Operations of Binary Trees</h3><h4 id="insertion" tabindex="-1"><a class="header-anchor" href="#insertion" aria-hidden="true">#</a> Insertion</h4><ul><li>Leaf nodes</li><li>Internal nodes<br><img src="'+v+'" alt="The process of inserting a node into a binary tree" loading="lazy"></li></ul><h4 id="deletion" tabindex="-1"><a class="header-anchor" href="#deletion" aria-hidden="true">#</a> Deletion</h4><ul><li>Node with zero or one children</li><li>Node with two children<br><img src="'+y+'" alt="The process of deleting an internal node in a binary tree" loading="lazy"></li></ul><h4 id="traversal" tabindex="-1"><a class="header-anchor" href="#traversal" aria-hidden="true">#</a> Traversal</h4><h5 id="depth-first-search-dfs" tabindex="-1"><a class="header-anchor" href="#depth-first-search-dfs" aria-hidden="true">#</a> Depth First Search(DFS)</h5><figure><img src="'+g+'" alt="depth first traversal of a binary tree" tabindex="0" loading="lazy"><figcaption>depth first traversal of a binary tree</figcaption></figure><ul><li>Pre-order(NLR), node visited at position red ●: F, B, A, D, C, E, G, I, H</li></ul>',15),P=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`procedure pre_order(node)
    if node = null
        return
    visit(node)
    pre_order(node.left)
    pre_order(node.right)
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),q=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`procedure pre_order(node)
    if node = null
        return
    stack ← empty stack
    stack.push(node)
    while not stack.isEmpty()
        node ← stack.pop()
        visit(node)
        // right child is pushed first so that left is processed first
        if node.right ≠ null
            stack.push(node.right)
        if node.left ≠ null
            stack.push(node.left)
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),R=e("ul",null,[e("li",null,"In-order(LNR), node visited at position green ●: A, B, C, D, E, F, G, H, I")],-1),V=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`procedure in_order(node)
    if node = null
        return
    in_order(node.left)
    visit(node)
    in_order(node.right)
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),M=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`procedure in_order(node)
    stack ← empty stack
    while not stack.isEmpty() or node ≠ null
        if node ≠ null
            stack.push(node)
            node ← node.left
        else
            node ← stack.pop()
            visit(node)
            node ← node.right
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),G=e("ul",null,[e("li",null,"Post-order(LRN), node visited at position blue ●: A, C, E, D, B, H, I, G, F")],-1),H=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`procedure post_order(node)
    if node = null
        return
    post_order(node.left)
    post_order(node.right)
    visit(node)
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),O=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`procedure post_order(node)
    stack ← empty stack
    lastNodeVisited ← null
    while not stack.isEmpty() or node ≠ null
        if node ≠ null
            stack.push(node)
            node ← node.left
        else
            peekNode ← stack.peek()
            // if right child exists and traversing node
            // from left child, then move right
            if peekNode.right ≠ null and lastNodeVisited ≠ peekNode.right
                node ← peekNode.right
            else
                visit(peekNode)
                lastNodeVisited ← stack.pop()
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),W=e("h5",{id:"breadth-first-search-bfs",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#breadth-first-search-bfs","aria-hidden":"true"},"#"),r(" Breadth First Search(BFS)")],-1),j=e("figure",null,[e("img",{src:h,alt:"breadth first search",tabindex:"0",loading:"lazy"}),e("figcaption",null,"breadth first search")],-1),J=e("ul",null,[e("li",null,"Level-order: F, B, G, A, D, I, C, E, H")],-1),K=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`procedure level_order(node)
    queue ← empty queue
    queue.enqueue(node)
    while not queue.isEmpty()
        node ← queue.dequeue()
        visit(node)
        if node.left ≠ null
            queue.enqueue(node.left)
        if node.right ≠ null
            queue.enqueue(node.right)
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"}),e("div",{class:"line-number"})])],-1),Q=d('<h2 id="exercise" tabindex="-1"><a class="header-anchor" href="#exercise" aria-hidden="true">#</a> Exercise</h2><h3 id="traversal-of-binary-trees" tabindex="-1"><a class="header-anchor" href="#traversal-of-binary-trees" aria-hidden="true">#</a> Traversal of Binary Trees</h3><p>[144: Binary Tree Pre-order Traversal]<br> [145: Binary Tree Post-order Traversal]<br> [94: Binary Tree In-order Traversal]<br> [102: Binary Tree Level Order Traversal]</p><h3 id="properties-of-binary-trees-1" tabindex="-1"><a class="header-anchor" href="#properties-of-binary-trees-1" aria-hidden="true">#</a> Properties of Binary Trees</h3><p>[101: Symmetric Tree]<br> [104: Maximum Depth of Binary Tree]<br> [111: Minimum Depth of Binary Tree]<br> [222: Count Complete Tree Nodes]<br> [110: Balanced Binary Tree]<br> [257: Binary Tree Paths]<br> [404: Sum of Left Leaves]<br> [513: Find Bottom Left Tree Value]<br> [112: Path Sum]</p><h3 id="operations-of-binary-trees-1" tabindex="-1"><a class="header-anchor" href="#operations-of-binary-trees-1" aria-hidden="true">#</a> Operations of Binary Trees</h3><p>[226: Invert Binary Tree]<br> [105: Construct Binary Tree from Pre-order and In-order Traversal]<br> [106: Construct Binary Tree from Post-order and In-order Traversal]<br> [654: Maximum Binary Tree]<br> [617: Merge Two Binary Trees]</p><h3 id="properties-of-binary-search-trees" tabindex="-1"><a class="header-anchor" href="#properties-of-binary-search-trees" aria-hidden="true">#</a> Properties of Binary Search Trees</h3><p>[700: Search in a Binary Search Tree]<br> [98: Validate Binary Search Tree]<br> [530: Minimum Absolute Difference in BST]<br> [501: Find Mode in Binary Search Tree]<br> [538: Convert BST to Greater Tree]</p><h3 id="common-ancestor-of-binary-trees" tabindex="-1"><a class="header-anchor" href="#common-ancestor-of-binary-trees" aria-hidden="true">#</a> Common Ancestor of Binary Trees</h3><p>[236: Lowest Common Ancestor of a Binary Tree]<br> [235: Lowest Common Ancestor of a Binary Search Tree]</p><h3 id="operations-of-binary-search-trees" tabindex="-1"><a class="header-anchor" href="#operations-of-binary-search-trees" aria-hidden="true">#</a> Operations of Binary Search Trees</h3><p>[701: Insert into a Binary Search Tree]<br> [450: Delete Node in a BST]<br> [669: Trim a Binary Search Tree]<br> [108: Convert Sorted Array to Binary Search Tree]<br> [109: Convert Sorted List to Binary Search Tree]</p><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary" aria-hidden="true">#</a> Summary</h2>',14);function U(X,Y){const o=l("ExternalLinkIcon"),s=l("CodeTabs");return T(),x("div",null,[w,k,e("p",null,[r("In computer science, a "),e("a",I,[A,t(o)]),r(" is a tree data structure in which each node has at most two children, referred to as the "),S,r(" and the "),C,r(". That is, it is a "),e("a",N,[L,t(o)]),r(" with k = 2. A "),D,r(" using set theory is that a binary tree is a tuple (L, S, R), where L and R are binary trees or the empty set and S is a singleton set containing the root."),F,z]),E,t(s,{id:"151",data:[{id:"Recursive Impl"},{id:"Iterative Impl"}]},{title0:n(({value:i,isActive:a})=>[r("Recursive Impl")]),title1:n(({value:i,isActive:a})=>[r("Iterative Impl")]),tab0:n(({value:i,isActive:a})=>[P]),tab1:n(({value:i,isActive:a})=>[q]),_:1}),R,t(s,{id:"166",data:[{id:"Recursive Impl"},{id:"Iterative Impl"}]},{title0:n(({value:i,isActive:a})=>[r("Recursive Impl")]),title1:n(({value:i,isActive:a})=>[r("Iterative Impl")]),tab0:n(({value:i,isActive:a})=>[V]),tab1:n(({value:i,isActive:a})=>[M]),_:1}),G,t(s,{id:"181",data:[{id:"Recursive Impl"},{id:"Iterative Impl"}]},{title0:n(({value:i,isActive:a})=>[r("Recursive Impl")]),title1:n(({value:i,isActive:a})=>[r("Iterative Impl")]),tab0:n(({value:i,isActive:a})=>[H]),tab1:n(({value:i,isActive:a})=>[O]),_:1}),W,j,J,t(s,{id:"202",data:[{id:"Iterative Impl"}]},{title0:n(({value:i,isActive:a})=>[r("Iterative Impl")]),tab0:n(({value:i,isActive:a})=>[K]),_:1}),Q])}const re=_(B,[["render",U],["__file","index.html.vue"]]);export{re as default};
