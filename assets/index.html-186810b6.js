import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o,c as s,a as e,d as t,w as n,e as l,b as a}from"./app-da19eeaa.js";const c={},h=l(`<h2 id="回溯" tabindex="-1"><a class="header-anchor" href="#回溯" aria-hidden="true">#</a> 回溯</h2><p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就<strong>回溯</strong>返回，尝试别的路径。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p>回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>回溯法解决的问题可以概括如下：</p><ul><li>组合问题：N个数⾥⾯按⼀定规则找出k个数的集合</li><li>切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式</li><li>⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集</li><li>排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯法解决的问题都可以抽象为树形结构。</p><p>回溯算法模板框架如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void backtracking(参数) {
    if (终⽌条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中孩⼦节点的数量就是集合的⼤⼩）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题" aria-hidden="true">#</a> 习题</h2><h3 id="组合" tabindex="-1"><a class="header-anchor" href="#组合" aria-hidden="true">#</a> 组合</h3>`,11),_=e("br",null,null,-1),u=e("br",null,null,-1),m=e("br",null,null,-1),b=e("br",null,null,-1),p=e("h3",{id:"分割",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#分割","aria-hidden":"true"},"#"),a(" 分割")],-1),v=e("br",null,null,-1),f=e("h3",{id:"子集",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#子集","aria-hidden":"true"},"#"),a(" 子集")],-1),g=e("br",null,null,-1),k=e("h3",{id:"排列",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#排列","aria-hidden":"true"},"#"),a(" 排列")],-1),x=e("br",null,null,-1),I=l('<h3 id="棋盘问题" tabindex="-1"><a class="header-anchor" href="#棋盘问题" aria-hidden="true">#</a> 棋盘问题</h3><p>[51: N皇后]<br> [52: N皇后II]<br> [37: 解数独]</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><p>[491: 递增子序列]<br> [332: 重新安排行程]</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',5);function z(N,V){const i=d("RouterLink");return o(),s("div",null,[h,e("p",null,[t(i,{to:"/zh/algorithm/leetcode/backtracking/77_combinations.html"},{default:n(()=>[a("77: 组合")]),_:1}),_,t(i,{to:"/zh/algorithm/leetcode/backtracking/17_letter_combinations_of_a_phone_number.html"},{default:n(()=>[a("17: 电话号码的字母组合")]),_:1}),u,t(i,{to:"/zh/algorithm/leetcode/backtracking/39_combination_sum.html"},{default:n(()=>[a("39: 组合总和")]),_:1}),m,t(i,{to:"/zh/algorithm/leetcode/backtracking/40_combination_sum_ii.html"},{default:n(()=>[a("40: 组合总和II")]),_:1}),b,t(i,{to:"/zh/algorithm/leetcode/backtracking/216_combination_sum_iii.html"},{default:n(()=>[a("216: 组合总和III")]),_:1})]),p,e("p",null,[t(i,{to:"/zh/algorithm/leetcode/backtracking/131_palindrome_partitioning.html"},{default:n(()=>[a("131: 分割回文串")]),_:1}),v,t(i,{to:"/zh/algorithm/leetcode/backtracking/93_restore_ip_addresses.html"},{default:n(()=>[a("93: 复原IP地址")]),_:1})]),f,e("p",null,[t(i,{to:"/zh/algorithm/leetcode/backtracking/78_subsets.html"},{default:n(()=>[a("78: 子集")]),_:1}),g,t(i,{to:"/zh/algorithm/leetcode/backtracking/90_subsets_ii.html"},{default:n(()=>[a("90: 子集II")]),_:1})]),k,e("p",null,[t(i,{to:"/zh/algorithm/leetcode/backtracking/46_permutations.html"},{default:n(()=>[a("46: 全排列")]),_:1}),x,t(i,{to:"/zh/algorithm/leetcode/backtracking/47_permutations_ii.html"},{default:n(()=>[a("47: 全排列II")]),_:1})]),I])}const C=r(c,[["render",z],["__file","index.html.vue"]]);export{C as default};
