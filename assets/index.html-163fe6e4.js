import{_ as a,a as e,b as r,c as i}from"./hash_table_average_insertion_time-4abb6ed9.js";import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{o as h,c as n,e as t}from"./app-556ba11a.js";const o={},s=t('<h2 id="哈希表的理论知识" tabindex="-1"><a class="header-anchor" href="#哈希表的理论知识" aria-hidden="true">#</a> 哈希表的理论知识</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><figure><img src="'+a+'" alt="hash table" tabindex="0" loading="lazy"><figcaption>hash table</figcaption></figure><h3 id="哈希函数" tabindex="-1"><a class="header-anchor" href="#哈希函数" aria-hidden="true">#</a> 哈希函数</h3><p>若关键字为<code>k</code>，则其值存放在<code>f(k)</code>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<code>f</code>为散列函数。</p><p>对不同的关键字可能得到同一散列地址，即<code>k1 != k2</code>，而<code>f(k1) = f(k2)</code>，这种现象称为<strong>冲突</strong>（Collision）。</p><h3 id="处理冲突" tabindex="-1"><a class="header-anchor" href="#处理冲突" aria-hidden="true">#</a> 处理冲突</h3><h4 id="_1-分离连接法" tabindex="-1"><a class="header-anchor" href="#_1-分离连接法" aria-hidden="true">#</a> 1. 分离连接法</h4><figure><img src="'+e+'" alt="separate chaining" tabindex="0" loading="lazy"><figcaption>separate chaining</figcaption></figure><h4 id="_2-开放定址法" tabindex="-1"><a class="header-anchor" href="#_2-开放定址法" aria-hidden="true">#</a> 2. 开放定址法</h4><ul><li><em><strong>线性探测</strong></em>: 逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。<br><img src="'+r+'" alt="linear probing" loading="lazy"></li><li><em><strong>平方探测</strong></em></li><li><em><strong>二次哈希</strong></em></li></ul><h3 id="载荷因子" tabindex="-1"><a class="header-anchor" href="#载荷因子" aria-hidden="true">#</a> 载荷因子</h3><p>散列表的载荷因子定义为：a = 填入表中的元素个数 / 散列表的长度</p><p>a是散列表装满程度的标志因子。由于表长是定值，a与&quot;填入表中的元素个数&quot;成正比，所以，a越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，a越小，表明填入表中的元素越少，产生冲突的可能性就越小。</p><p>对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。</p><figure><img src="'+i+'" alt="load factor" tabindex="0" loading="lazy"><figcaption>load factor</figcaption></figure><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题" aria-hidden="true">#</a> 习题</h2><h3 id="有效的字母异位词" tabindex="-1"><a class="header-anchor" href="#有效的字母异位词" aria-hidden="true">#</a> 有效的字母异位词</h3><p>[242: 有效的字母异位词]<br> [383: 赎金信]<br> [49: 字母异位词分组]<br> [438: 找到字符串中所有字母异位词]</p><h3 id="两个数组的交集" tabindex="-1"><a class="header-anchor" href="#两个数组的交集" aria-hidden="true">#</a> 两个数组的交集</h3><p>[349: 两个数组的交集]<br> [350: 两个数组的交集II]</p><h3 id="快乐数" tabindex="-1"><a class="header-anchor" href="#快乐数" aria-hidden="true">#</a> 快乐数</h3><p>[202: 快乐数]</p><h3 id="两数之和" tabindex="-1"><a class="header-anchor" href="#两数之和" aria-hidden="true">#</a> 两数之和</h3><p>[1: 两数之和]</p><h3 id="三数之和" tabindex="-1"><a class="header-anchor" href="#三数之和" aria-hidden="true">#</a> 三数之和</h3><p>[15: 三数之和]<br> [16: 最接近的三数之和]</p><h3 id="四数之和" tabindex="-1"><a class="header-anchor" href="#四数之和" aria-hidden="true">#</a> 四数之和</h3><p>[18: 四数之和]<br> [454: 四数之和II]</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',31),c=[s];function l(p,f){return h(),n("div",null,c)}const _=d(o,[["render",l],["__file","index.html.vue"]]);export{_ as default};
