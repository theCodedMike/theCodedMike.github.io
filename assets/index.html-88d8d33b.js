import{_ as o,a as i,b as l,c as d}from"./hash_table_average_insertion_time-4abb6ed9.js";import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as c,c as _,a,d as h,w as r,e as u,b as e}from"./app-6c2e7e57.js";const m={},f=u('<h2 id="哈希表的理论知识" tabindex="-1"><a class="header-anchor" href="#哈希表的理论知识" aria-hidden="true">#</a> 哈希表的理论知识</h2><h3 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。这个映射函数称做<strong>散列函数</strong>，存放记录的数组称做<strong>散列表</strong>。</p><figure><img src="'+o+'" alt="hash table" tabindex="0" loading="lazy"><figcaption>hash table</figcaption></figure><h3 id="哈希函数" tabindex="-1"><a class="header-anchor" href="#哈希函数" aria-hidden="true">#</a> 哈希函数</h3><p>若关键字为<code>k</code>，则其值存放在<code>f(k)</code>的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系<code>f</code>为散列函数。</p><p>对不同的关键字可能得到同一散列地址，即<code>k1 != k2</code>，而<code>f(k1) = f(k2)</code>，这种现象称为<strong>冲突</strong>（Collision）。</p><h3 id="处理冲突" tabindex="-1"><a class="header-anchor" href="#处理冲突" aria-hidden="true">#</a> 处理冲突</h3><h4 id="_1-分离连接法" tabindex="-1"><a class="header-anchor" href="#_1-分离连接法" aria-hidden="true">#</a> 1. 分离连接法</h4><figure><img src="'+i+'" alt="separate chaining" tabindex="0" loading="lazy"><figcaption>separate chaining</figcaption></figure><h4 id="_2-开放定址法" tabindex="-1"><a class="header-anchor" href="#_2-开放定址法" aria-hidden="true">#</a> 2. 开放定址法</h4><ul><li><em><strong>线性探测</strong></em>: 逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。<br><img src="'+l+'" alt="linear probing" loading="lazy"></li><li><em><strong>平方探测</strong></em></li><li><em><strong>二次哈希</strong></em></li></ul><h3 id="载荷因子" tabindex="-1"><a class="header-anchor" href="#载荷因子" aria-hidden="true">#</a> 载荷因子</h3><p>散列表的载荷因子定义为：a = 填入表中的元素个数 / 散列表的长度</p><p>a是散列表装满程度的标志因子。由于表长是定值，a与&quot;填入表中的元素个数&quot;成正比，所以，a越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，a越小，表明填入表中的元素越少，产生冲突的可能性就越小。</p><p>对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。</p><figure><img src="'+d+'" alt="load factor" tabindex="0" loading="lazy"><figcaption>load factor</figcaption></figure><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题" aria-hidden="true">#</a> 习题</h2><h3 id="有效的字母异位词" tabindex="-1"><a class="header-anchor" href="#有效的字母异位词" aria-hidden="true">#</a> 有效的字母异位词</h3>',19),g=a("br",null,null,-1),b=a("br",null,null,-1),p=a("br",null,null,-1),x=a("h3",{id:"两个数组的交集",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#两个数组的交集","aria-hidden":"true"},"#"),e(" 两个数组的交集")],-1),z=a("br",null,null,-1),k=a("h3",{id:"快乐数",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#快乐数","aria-hidden":"true"},"#"),e(" 快乐数")],-1),y=a("h3",{id:"两数之和",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#两数之和","aria-hidden":"true"},"#"),e(" 两数之和")],-1),w=a("h3",{id:"三数之和",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#三数之和","aria-hidden":"true"},"#"),e(" 三数之和")],-1),v=a("br",null,null,-1),I=a("h3",{id:"四数之和",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#四数之和","aria-hidden":"true"},"#"),e(" 四数之和")],-1),N=a("br",null,null,-1),V=a("h2",{id:"总结",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),e(" 总结")],-1);function B(C,q){const t=s("RouterLink");return c(),_("div",null,[f,a("p",null,[h(t,{to:"/zh/algorithm/leetcode/hashtable/242_valid_anagram.html"},{default:r(()=>[e("242: 有效的字母异位词")]),_:1}),g,h(t,{to:"/zh/algorithm/leetcode/hashtable/383_ransom_note.html"},{default:r(()=>[e("383: 赎金信")]),_:1}),b,h(t,{to:"/zh/algorithm/leetcode/hashtable/49_group_anagrams.html"},{default:r(()=>[e("49: 字母异位词分组")]),_:1}),p,h(t,{to:"/zh/algorithm/leetcode/hashtable/438_find_all_anagrams_in_a_string.html"},{default:r(()=>[e("438: 找到字符串中所有字母异位词")]),_:1})]),x,a("p",null,[h(t,{to:"/zh/algorithm/leetcode/hashtable/349_intersection_of_two_arrays.html"},{default:r(()=>[e("349: 两个数组的交集")]),_:1}),z,h(t,{to:"/zh/algorithm/leetcode/hashtable/350_intersection_of_two_arrays_ii.html"},{default:r(()=>[e("350: 两个数组的交集II")]),_:1})]),k,a("p",null,[h(t,{to:"/zh/algorithm/leetcode/hashtable/202_happy_number.html"},{default:r(()=>[e("202: 快乐数")]),_:1})]),y,a("p",null,[h(t,{to:"/zh/algorithm/leetcode/hashtable/1_two_sum.html"},{default:r(()=>[e("1: 两数之和")]),_:1})]),w,a("p",null,[h(t,{to:"/zh/algorithm/leetcode/hashtable/15_three_sum.html"},{default:r(()=>[e("15: 三数之和")]),_:1}),v,h(t,{to:"/zh/algorithm/leetcode/hashtable/16_three_sum_closest.html"},{default:r(()=>[e("16: 最接近的三数之和")]),_:1})]),I,a("p",null,[h(t,{to:"/zh/algorithm/leetcode/hashtable/18_four_sum.html"},{default:r(()=>[e("18: 四数之和")]),_:1}),N,h(t,{to:"/zh/algorithm/leetcode/hashtable/454_four_sum_ii.html"},{default:r(()=>[e("454: 四数之和II")]),_:1})]),V])}const H=n(m,[["render",B],["__file","index.html.vue"]]);export{H as default};
