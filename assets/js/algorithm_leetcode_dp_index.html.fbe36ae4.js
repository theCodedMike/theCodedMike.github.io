"use strict";(self.webpackChunkmike_blog=self.webpackChunkmike_blog||[]).push([[42843],{44411:(e,a,r)=>{r.r(a),r.d(a,{comp:()=>o,data:()=>i});var n=r(60362);const t={},o=(0,r(75726).A)(t,[["render",function(e,a){const r=(0,n.g2)("RouteLink");return(0,n.uX)(),(0,n.CE)("div",null,[a[15]||(a[15]=(0,n.Fv)('<h2 id="dynamic-programming" tabindex="-1"><a class="header-anchor" href="#dynamic-programming"><span>Dynamic Programming</span></a></h2><h3 id="what-is-dynamic-programming-dp" tabindex="-1"><a class="header-anchor" href="#what-is-dynamic-programming-dp"><span>What is Dynamic Programming (DP)?</span></a></h3><p><strong>Dynamic Programming (DP)</strong> is a method used in mathematics and computer science to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems.</p><h3 id="how-does-dynamic-programming-dp-work" tabindex="-1"><a class="header-anchor" href="#how-does-dynamic-programming-dp-work"><span>How Does Dynamic Programming (DP) Work?</span></a></h3><ul><li><strong>Identify Subproblems:</strong> Divide the main problem into smaller, independent subproblems.</li><li><strong>Store Solutions:</strong> Solve each subproblem and store the solution in a table or array.</li><li><strong>Build Up Solutions:</strong> Use the stored solutions to build up the solution to the main problem.</li><li><strong>Avoid Redundancy:</strong> By storing solutions, DP ensures that each subproblem is solved only once, reducing computation time.</li></ul><h3 id="when-to-use-dynamic-programming-dp" tabindex="-1"><a class="header-anchor" href="#when-to-use-dynamic-programming-dp"><span>When to Use Dynamic Programming (DP)?</span></a></h3><p>Dynamic programming is an optimization technique used when solving problems that consists of the following characteristics:</p><ol><li><strong>Optimal Substructure:</strong> Optimal substructure means that we combine the optimal results of subproblems to achieve the optimal result of the bigger problem.</li><li><strong>Overlapping Subproblems:</strong> The same subproblems are solved repeatedly in different parts of the problem.</li></ol><h2 id="exercise" tabindex="-1"><a class="header-anchor" href="#exercise"><span>Exercise</span></a></h2><h3 id="fundamental-problems" tabindex="-1"><a class="header-anchor" href="#fundamental-problems"><span>Fundamental Problems</span></a></h3>',10)),(0,n.Lk)("p",null,[(0,n.bF)(r,{to:"/algorithm/leetcode/dp/509_fibonacci_number.html"},{default:(0,n.k6)(()=>[...a[0]||(a[0]=[(0,n.eW)("509: Fibonacci Number",-1)])]),_:1}),a[7]||(a[7]=(0,n.Lk)("br",null,null,-1)),(0,n.bF)(r,{to:"/algorithm/leetcode/dp/70_climbing_stairs.html"},{default:(0,n.k6)(()=>[...a[1]||(a[1]=[(0,n.eW)("70: Climbing Stairs",-1)])]),_:1}),a[8]||(a[8]=(0,n.Lk)("br",null,null,-1)),(0,n.bF)(r,{to:"/algorithm/leetcode/dp/1137_nth_tribonacci_number.html"},{default:(0,n.k6)(()=>[...a[2]||(a[2]=[(0,n.eW)("1137: N-th Tribonacci Number",-1)])]),_:1}),a[9]||(a[9]=(0,n.Lk)("br",null,null,-1)),(0,n.bF)(r,{to:"/algorithm/leetcode/dp/746_min_cost_climbing_stairs.html"},{default:(0,n.k6)(()=>[...a[3]||(a[3]=[(0,n.eW)("746: Min Cost Climbing Stairs",-1)])]),_:1}),a[10]||(a[10]=(0,n.Lk)("br",null,null,-1)),(0,n.bF)(r,{to:"/algorithm/leetcode/dp/740_delete_and_earn.html"},{default:(0,n.k6)(()=>[...a[4]||(a[4]=[(0,n.eW)("740: Delete and Earn",-1)])]),_:1}),a[11]||(a[11]=(0,n.Lk)("br",null,null,-1)),(0,n.bF)(r,{to:"/algorithm/leetcode/dp/198_house_robber.html"},{default:(0,n.k6)(()=>[...a[5]||(a[5]=[(0,n.eW)("198: House Robber",-1)])]),_:1}),a[12]||(a[12]=(0,n.Lk)("br",null,null,-1)),(0,n.bF)(r,{to:"/algorithm/leetcode/dp/343_integer_break.html"},{default:(0,n.k6)(()=>[...a[6]||(a[6]=[(0,n.eW)("343: Integer Break",-1)])]),_:1})]),a[16]||(a[16]=(0,n.Lk)("h3",{id:"matrix",tabindex:"-1"},[(0,n.Lk)("a",{class:"header-anchor",href:"#matrix"},[(0,n.Lk)("span",null,"Matrix")])],-1)),(0,n.Lk)("p",null,[(0,n.bF)(r,{to:"/algorithm/leetcode/dp/62_unique_paths.html"},{default:(0,n.k6)(()=>[...a[13]||(a[13]=[(0,n.eW)("62: Unique Paths",-1)])]),_:1}),a[14]||(a[14]=(0,n.Fv)('<br><a href="">64: Minimum Path Sum</a><br><a href="">63: Unique Paths II</a><br><a href="">120: Triangle</a><br><a href="">931: Minimum Falling Path Sum</a><br><a href="">221: Maximal Square</a>',10))]),a[17]||(a[17]=(0,n.Fv)('<h3 id="knapsack-problem" tabindex="-1"><a class="header-anchor" href="#knapsack-problem"><span>Knapsack Problem</span></a></h3><p><a href="">416: Partition Equal Subset Sum</a><br><a href="">1049: Last Stone Weight II</a><br><a href="">494: Target Sum</a><br><a href="">474: Ones and Zeroes</a></p><h3 id="knapsack-problem-1" tabindex="-1"><a class="header-anchor" href="#knapsack-problem-1"><span>Knapsack Problem</span></a></h3><p><a href="">518: Coin Change II</a><br><a href="">322: Coin Change</a><br><a href="">279: Perfect Squares</a><br><a href="">377: Combination Sum IV</a><br><a href="">139: Word Break</a></p><h3 id="house-robber" tabindex="-1"><a class="header-anchor" href="#house-robber"><span>House Robber</span></a></h3><p><a href="">213: House Robber II</a><br><a href="">337: House Robber III</a><br><a href="">96: Unique Binary Search Trees</a><br><a href="">95: Unique Binary Search Trees II</a><br><a href="">124: Binary Tree Maximum Path Sum</a></p><h3 id="buy-and-sell-stock" tabindex="-1"><a class="header-anchor" href="#buy-and-sell-stock"><span>Buy and Sell Stock</span></a></h3><p><a href="">121: Best Time to Buy and Sell Stock</a><br><a href="">123: Best Time to Buy and Sell Stock III</a><br><a href="">188: Best Time to Buy and Sell Stock IV</a><br><a href="">309: Best Time to Buy and Sell Stock with Cooldown</a></p><h3 id="subsequence" tabindex="-1"><a class="header-anchor" href="#subsequence"><span>Subsequence</span></a></h3><p><a href="">1143: Longest Common Subsequence</a><br><a href="">1035: Uncrossed Lines</a><br><a href="">300: Longest Increasing Subsequence</a><br><a href="">673: Number of Longest Increasing Subsequence</a><br><a href="">1312: Minimum Insertion Steps to Make a String Palindrome</a><br><a href="">646: Maximum Length of Pair Chain</a><br><a href="">1218: Longest Arithmetic Subsequence of Given Difference</a><br><a href="">1027: Longest Arithmetic Subsequence</a><br><a href="">354: Russian Doll Envelopes</a><br><a href="">1964: Find the Longest Valid Obstacle Course at Each Position</a></p><h3 id="subsequence-1" tabindex="-1"><a class="header-anchor" href="#subsequence-1"><span>Subsequence</span></a></h3><p><a href="">674: Longest Continuous Increasing Subsequence</a><br><a href="">718: Maximum Length of Repeated Subarray</a></p><h3 id="edit-distance" tabindex="-1"><a class="header-anchor" href="#edit-distance"><span>Edit Distance</span></a></h3><p><a href="">392: Is Subsequence</a><br><a href="">115: Distinct Subsequences</a><br><a href="">583: Delete Operation for Two Strings</a><br><a href="">712: Minimum ASCII Delete Sum for Two Strings</a><br><a href="">72: Edit Distance</a></p><h3 id="palindrome" tabindex="-1"><a class="header-anchor" href="#palindrome"><span>Palindrome</span></a></h3><p><a href="">5: Longest Palindromic Substring</a><br><a href="">647: Palindromic Substrings</a><br><a href="">516: Longest Palindromic Subsequence</a></p><h3 id="other" tabindex="-1"><a class="header-anchor" href="#other"><span>Other</span></a></h3><p><a href="">2140: Solving Questions With Brainpower</a><br><a href="">2466: Count Ways To Build Good Strings</a><br><a href="">91: Decode Ways</a><br><a href="">983: Minimum Cost For Tickets</a><br><a href="">790: Domino and Tromino Tiling</a></p><h2 id="summary" tabindex="-1"><a class="header-anchor" href="#summary"><span>Summary</span></a></h2>',19))])}]]),i=JSON.parse('{"path":"/algorithm/leetcode/dp/","title":"Dynamic Programming","lang":"en-US","frontmatter":{"title":"Dynamic Programming","icon":"discover","date":"2024-03-28T00:00:00.000Z","dir":{"order":10},"category":"leetcode","tag":"dynamic programming","sticky":false,"description":"Dynamic Programming What is Dynamic Programming (DP)? Dynamic Programming (DP) is a method used in mathematics and computer science to solve complex problems by breaking them do...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dynamic Programming\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-16T14:46:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mike\\"}]}"],["meta",{"property":"og:url","content":"https://thecodedmike.github.io/algorithm/leetcode/dp/"}],["meta",{"property":"og:site_name","content":"Mike\'s Blog"}],["meta",{"property":"og:title","content":"Dynamic Programming"}],["meta",{"property":"og:description","content":"Dynamic Programming What is Dynamic Programming (DP)? Dynamic Programming (DP) is a method used in mathematics and computer science to solve complex problems by breaking them do..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-16T14:46:57.000Z"}],["meta",{"property":"article:tag","content":"dynamic programming"}],["meta",{"property":"article:published_time","content":"2024-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-16T14:46:57.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://thecodedmike.github.io/zh/algorithm/leetcode/dp/"}]]},"git":{"createdTime":1695811035000,"updatedTime":1713278817000,"contributors":[{"name":"mike","username":"mike","email":"lixiaofeng1115@outlook.com","commits":10,"url":"https://github.com/mike"}]},"readingTime":{"minutes":1.65,"words":495},"filePathRelative":"algorithm/leetcode/dp/README.md","excerpt":"<h2>Dynamic Programming</h2>\\n<h3>What is Dynamic Programming (DP)?</h3>\\n<p><strong>Dynamic Programming (DP)</strong> is a method used in mathematics and computer science to solve complex problems by breaking them down into simpler subproblems. By solving each subproblem only once and storing the results, it avoids redundant computations, leading to more efficient solutions for a wide range of problems.</p>","autoDesc":true}')},75726:(e,a)=>{a.A=(e,a)=>{const r=e.__vccOpts||e;for(const[e,n]of a)r[e]=n;return r}}}]);