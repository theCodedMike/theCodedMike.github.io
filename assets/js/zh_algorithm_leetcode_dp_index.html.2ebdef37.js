"use strict";(self.webpackChunkmike_blog=self.webpackChunkmike_blog||[]).push([[24580],{56455:(a,e,r)=>{r.r(e),r.d(e,{comp:()=>n,data:()=>i});var t=r(60362);const h={},n=(0,r(75726).A)(h,[["render",function(a,e){const r=(0,t.g2)("RouteLink");return(0,t.uX)(),(0,t.CE)("div",null,[e[15]||(e[15]=(0,t.Fv)('<h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h2><h3 id="动态规划概述" tabindex="-1"><a class="header-anchor" href="#动态规划概述"><span>动态规划概述</span></a></h3><p><strong>动态规划</strong>(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。</p><p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分解成若干个互相联系的阶段，在它的每一个阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。这种把一个问题看做是一个前后关联具有链状结构的多阶段过程就称为<strong>多阶段决策过程</strong>，这种问题称为<strong>多阶段决策最优化问题</strong>。</p><h3 id="动态规划算法的基本思想" tabindex="-1"><a class="header-anchor" href="#动态规划算法的基本思想"><span>动态规划算法的基本思想</span></a></h3><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中得到原问题的解。与分治法不同的是，适用于动态规划求解的问题，经分解后得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。</p><h3 id="动态规划算法的基本模型" tabindex="-1"><a class="header-anchor" href="#动态规划算法的基本模型"><span>动态规划算法的基本模型</span></a></h3><ol><li>确定问题的决策对象</li><li>对决策过程划分阶段</li><li>对各阶段确定状态变量</li><li>根据状态变量确定费用函数和目标函数</li><li>建立各阶段状态变量的转移过程，确定状态转移方程</li></ol><h3 id="动态规划算法的适用条件" tabindex="-1"><a class="header-anchor" href="#动态规划算法的适用条件"><span>动态规划算法的适用条件</span></a></h3><ol><li>最优化原理（最优子结构性质）：整个问题的最优解可以通过求解子问题得到（通过子问题的最优解构造出全局最优解）。</li><li>无后效性：将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。</li><li>子问题的重叠性：如果有大量的重叠子问题，可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。</li></ol><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题"><span>习题</span></a></h2><h3 id="基础题目" tabindex="-1"><a class="header-anchor" href="#基础题目"><span>基础题目</span></a></h3>',12)),(0,t.Lk)("p",null,[(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/509_fibonacci_number.html"},{default:(0,t.k6)(()=>[...e[0]||(e[0]=[(0,t.eW)("509: 斐波那契数",-1)])]),_:1}),e[7]||(e[7]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/70_climbing_stairs.html"},{default:(0,t.k6)(()=>[...e[1]||(e[1]=[(0,t.eW)("70: 爬楼梯",-1)])]),_:1}),e[8]||(e[8]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/1137_nth_tribonacci_number.html"},{default:(0,t.k6)(()=>[...e[2]||(e[2]=[(0,t.eW)("1137: 第N个泰波那契数",-1)])]),_:1}),e[9]||(e[9]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/746_min_cost_climbing_stairs.html"},{default:(0,t.k6)(()=>[...e[3]||(e[3]=[(0,t.eW)("746: 使用最小花费爬楼梯",-1)])]),_:1}),e[10]||(e[10]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/740_delete_and_earn.html"},{default:(0,t.k6)(()=>[...e[4]||(e[4]=[(0,t.eW)("740: 删除并获得点数",-1)])]),_:1}),e[11]||(e[11]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/198_house_robber.html"},{default:(0,t.k6)(()=>[...e[5]||(e[5]=[(0,t.eW)("198: 打家劫舍",-1)])]),_:1}),e[12]||(e[12]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/343_integer_break.html"},{default:(0,t.k6)(()=>[...e[6]||(e[6]=[(0,t.eW)("343: 整数拆分",-1)])]),_:1})]),e[16]||(e[16]=(0,t.Lk)("h3",{id:"矩阵",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#矩阵"},[(0,t.Lk)("span",null,"矩阵")])],-1)),(0,t.Lk)("p",null,[(0,t.bF)(r,{to:"/zh/algorithm/leetcode/dp/62_unique_paths.html"},{default:(0,t.k6)(()=>[...e[13]||(e[13]=[(0,t.eW)("62: 不同路径",-1)])]),_:1}),e[14]||(e[14]=(0,t.Fv)('<br><a href="">64: 最小路径和</a><br><a href="">63: 不同路径II</a><br><a href="">120: 三角形最小路径和</a><br><a href="">931: 下降路径最小和</a><br><a href="">221: 最大正方形</a>',10))]),e[17]||(e[17]=(0,t.Fv)('<h3 id="背包问题" tabindex="-1"><a class="header-anchor" href="#背包问题"><span>背包问题</span></a></h3><p><a href="">416: 分割等和子集</a><br><a href="">1049: 最后一块石头的重量II</a><br><a href="">494: 目标和</a><br><a href="">474: 一和零</a></p><h3 id="完全背包" tabindex="-1"><a class="header-anchor" href="#完全背包"><span>完全背包</span></a></h3><p><a href="">518: 零钱兑换II</a><br><a href="">322: 零钱兑换</a><br><a href="">279: 完全平方数</a><br><a href="">377: 组合总和IV</a><br><a href="">139: 单词拆分</a></p><h3 id="动态规划在树的应用" tabindex="-1"><a class="header-anchor" href="#动态规划在树的应用"><span>动态规划在树的应用</span></a></h3><p><a href="">213: 打家劫舍II</a><br><a href="">337: 打家劫舍III</a><br><a href="">96: 不同的二叉搜索树</a><br><a href="">95: 不同的二叉搜索树II</a><br><a href="">124: 二叉树中的最大路径和</a></p><h3 id="买卖股票的最佳时间-状态机" tabindex="-1"><a class="header-anchor" href="#买卖股票的最佳时间-状态机"><span>买卖股票的最佳时间/状态机</span></a></h3><p><a href="">121: 买卖股票的最佳时机</a><br><a href="">123: 买卖股票的最佳时机III</a><br><a href="">188: 买卖股票的最佳时机IV</a><br><a href="">309: 最佳买卖股票时机含冷冻期</a></p><h3 id="子序列-不连续" tabindex="-1"><a class="header-anchor" href="#子序列-不连续"><span>子序列（不连续）</span></a></h3><p><a href="">1143: 最长公共子序列</a><br><a href="">1035: 不相交的线</a><br><a href="">300: 最长递增子序列</a><br><a href="">673: 最长递增子序列的个数</a><br><a href="">1312: 让字符串成为回文串的最少插入次数</a><br><a href="">646: 最长数对链</a><br><a href="">1218: 最长定差子序列</a><br><a href="">1027: 最长等差数列</a><br><a href="">354: 俄罗斯套娃信封问题</a><br><a href="">1964: 找出到每个位置为止最长的有效障碍赛跑路线</a></p><h3 id="子序列-连续" tabindex="-1"><a class="header-anchor" href="#子序列-连续"><span>子序列（连续）</span></a></h3><p><a href="">674: 最长连续递增序列</a><br><a href="">718: 最长重复子数组</a></p><h3 id="编辑距离" tabindex="-1"><a class="header-anchor" href="#编辑距离"><span>编辑距离</span></a></h3><p><a href="">392: 判断子序列</a><br><a href="">115: 不同的子序列</a><br><a href="">583: 两个字符串的删除操作</a><br><a href="">712: 两个字符串的最小ASCII删除和</a><br><a href="">72: 编辑距离</a></p><h3 id="回文" tabindex="-1"><a class="header-anchor" href="#回文"><span>回文</span></a></h3><p><a href="">5: 最长回文子串</a><br><a href="">647: 回文子串</a><br><a href="">516: 最长回文子序列</a></p><h3 id="动态规划-一维" tabindex="-1"><a class="header-anchor" href="#动态规划-一维"><span>动态规划：一维</span></a></h3><p><a href="">2140: 解决智力问题</a><br><a href="">2466: 统计构造好字符串的方案数</a><br><a href="">91: 解码方法</a><br><a href="">983: 最低票价</a><br><a href="">790: 多米诺和托米诺平铺</a></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2>',19))])}]]),i=JSON.parse('{"path":"/zh/algorithm/leetcode/dp/","title":"动态规划","lang":"zh-CN","frontmatter":{"title":"动态规划","icon":"discover","date":"2024-03-28T00:00:00.000Z","dir":{"order":10},"category":"leetcode","tag":"dynamic programming","sticky":false,"description":"动态规划 动态规划概述 动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。 在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分解成若干个互相联系的阶段，在它的每一个阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"动态规划\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-04-16T14:46:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mike\\"}]}"],["meta",{"property":"og:url","content":"https://thecodedmike.github.io/zh/algorithm/leetcode/dp/"}],["meta",{"property":"og:site_name","content":"Mike的博客"}],["meta",{"property":"og:title","content":"动态规划"}],["meta",{"property":"og:description","content":"动态规划 动态规划概述 动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。 在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分解成若干个互相联系的阶段，在它的每一个阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-04-16T14:46:57.000Z"}],["meta",{"property":"article:tag","content":"dynamic programming"}],["meta",{"property":"article:published_time","content":"2024-03-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-04-16T14:46:57.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://thecodedmike.github.io/algorithm/leetcode/dp/"}]]},"git":{"createdTime":1695811035000,"updatedTime":1713278817000,"contributors":[{"name":"mike","username":"mike","email":"lixiaofeng1115@outlook.com","commits":10,"url":"https://github.com/mike"}]},"readingTime":{"minutes":4.54,"words":1363},"filePathRelative":"zh/algorithm/leetcode/dp/README.md","excerpt":"<h2>动态规划</h2>\\n<h3>动态规划概述</h3>\\n<p><strong>动态规划</strong>(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。</p>\\n<p>在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分解成若干个互相联系的阶段，在它的每一个阶段都需要作出决策，从而使整个过程达到最好的活动效果。因此各个阶段决策的选取不能任意确定，它依赖于当前面临的状态，又影响以后的发展。当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线。这种把一个问题看做是一个前后关联具有链状结构的多阶段过程就称为<strong>多阶段决策过程</strong>，这种问题称为<strong>多阶段决策最优化问题</strong>。</p>","autoDesc":true}')},75726:(a,e)=>{e.A=(a,e)=>{const r=a.__vccOpts||a;for(const[a,t]of e)r[a]=t;return r}}}]);