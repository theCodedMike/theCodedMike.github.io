"use strict";(self.webpackChunkmike_blog=self.webpackChunkmike_blog||[]).push([[95210],{75726:(e,a)=>{a.A=(e,a)=>{const n=e.__vccOpts||e;for(const[e,t]of a)n[e]=t;return n}},85702:(e,a,n)=>{n.r(a),n.d(a,{comp:()=>i,data:()=>s});var t=n(60362);const l={},i=(0,n(75726).A)(l,[["render",function(e,a){const n=(0,t.g2)("RouteLink");return(0,t.uX)(),(0,t.CE)("div",null,[a[28]||(a[28]=(0,t.Fv)('<h2 id="回溯" tabindex="-1"><a class="header-anchor" href="#回溯"><span>回溯</span></a></h2><p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就<strong>回溯</strong>返回，尝试别的路径。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p>回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>回溯法解决的问题可以概括如下：</p><ul><li>组合问题：N个数⾥⾯按⼀定规则找出k个数的集合</li><li>切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式</li><li>⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集</li><li>排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯法解决的问题都可以抽象为树形结构。</p><p>回溯算法模板框架如下：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-text"><span class="line"><span>void backtracking(参数) {</span></span>\n<span class="line"><span>    if (终⽌条件) {</span></span>\n<span class="line"><span>        存放结果;</span></span>\n<span class="line"><span>        return;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    for (选择：本层集合中元素（树中孩⼦节点的数量就是集合的⼤⼩）) {</span></span>\n<span class="line"><span>        处理节点;</span></span>\n<span class="line"><span>        backtracking(路径，选择列表); // 递归</span></span>\n<span class="line"><span>        回溯，撤销处理结果;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题"><span>习题</span></a></h2><h3 id="组合" tabindex="-1"><a class="header-anchor" href="#组合"><span>组合</span></a></h3>',11)),(0,t.Lk)("p",null,[(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/77_combinations.html"},{default:(0,t.k6)(()=>[...a[0]||(a[0]=[(0,t.eW)("77: 组合",-1)])]),_:1}),a[5]||(a[5]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/17_letter_combinations_of_a_phone_number.html"},{default:(0,t.k6)(()=>[...a[1]||(a[1]=[(0,t.eW)("17: 电话号码的字母组合",-1)])]),_:1}),a[6]||(a[6]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/39_combination_sum.html"},{default:(0,t.k6)(()=>[...a[2]||(a[2]=[(0,t.eW)("39: 组合总和",-1)])]),_:1}),a[7]||(a[7]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/40_combination_sum_ii.html"},{default:(0,t.k6)(()=>[...a[3]||(a[3]=[(0,t.eW)("40: 组合总和II",-1)])]),_:1}),a[8]||(a[8]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/216_combination_sum_iii.html"},{default:(0,t.k6)(()=>[...a[4]||(a[4]=[(0,t.eW)("216: 组合总和III",-1)])]),_:1})]),a[29]||(a[29]=(0,t.Lk)("h3",{id:"分割",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#分割"},[(0,t.Lk)("span",null,"分割")])],-1)),(0,t.Lk)("p",null,[(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/131_palindrome_partitioning.html"},{default:(0,t.k6)(()=>[...a[9]||(a[9]=[(0,t.eW)("131: 分割回文串",-1)])]),_:1}),a[11]||(a[11]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/93_restore_ip_addresses.html"},{default:(0,t.k6)(()=>[...a[10]||(a[10]=[(0,t.eW)("93: 复原IP地址",-1)])]),_:1})]),a[30]||(a[30]=(0,t.Lk)("h3",{id:"子集",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#子集"},[(0,t.Lk)("span",null,"子集")])],-1)),(0,t.Lk)("p",null,[(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/78_subsets.html"},{default:(0,t.k6)(()=>[...a[12]||(a[12]=[(0,t.eW)("78: 子集",-1)])]),_:1}),a[14]||(a[14]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/90_subsets_ii.html"},{default:(0,t.k6)(()=>[...a[13]||(a[13]=[(0,t.eW)("90: 子集II",-1)])]),_:1})]),a[31]||(a[31]=(0,t.Lk)("h3",{id:"排列",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#排列"},[(0,t.Lk)("span",null,"排列")])],-1)),(0,t.Lk)("p",null,[(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/46_permutations.html"},{default:(0,t.k6)(()=>[...a[15]||(a[15]=[(0,t.eW)("46: 全排列",-1)])]),_:1}),a[17]||(a[17]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/47_permutations_ii.html"},{default:(0,t.k6)(()=>[...a[16]||(a[16]=[(0,t.eW)("47: 全排列II",-1)])]),_:1})]),a[32]||(a[32]=(0,t.Lk)("h3",{id:"棋盘问题",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#棋盘问题"},[(0,t.Lk)("span",null,"棋盘问题")])],-1)),(0,t.Lk)("p",null,[(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/51_n_queens.html"},{default:(0,t.k6)(()=>[...a[18]||(a[18]=[(0,t.eW)("51: N皇后",-1)])]),_:1}),a[22]||(a[22]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/52_n_queens_ii.html"},{default:(0,t.k6)(()=>[...a[19]||(a[19]=[(0,t.eW)("52: N皇后II",-1)])]),_:1}),a[23]||(a[23]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/36_valid_sudoku.html"},{default:(0,t.k6)(()=>[...a[20]||(a[20]=[(0,t.eW)("36: 有效的数独",-1)])]),_:1}),a[24]||(a[24]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/37_sudoku_solver.html"},{default:(0,t.k6)(()=>[...a[21]||(a[21]=[(0,t.eW)("37: 解数独",-1)])]),_:1})]),a[33]||(a[33]=(0,t.Lk)("h3",{id:"其他",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#其他"},[(0,t.Lk)("span",null,"其他")])],-1)),(0,t.Lk)("p",null,[(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/491_non_decreasing_subsequences.html"},{default:(0,t.k6)(()=>[...a[25]||(a[25]=[(0,t.eW)("491: 递增子序列",-1)])]),_:1}),a[27]||(a[27]=(0,t.Lk)("br",null,null,-1)),(0,t.bF)(n,{to:"/zh/algorithm/leetcode/backtracking/332_reconstruct_itinerary.html"},{default:(0,t.k6)(()=>[...a[26]||(a[26]=[(0,t.eW)("332: 重新安排行程",-1)])]),_:1})]),a[34]||(a[34]=(0,t.Lk)("h2",{id:"总结",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#总结"},[(0,t.Lk)("span",null,"总结")])],-1))])}]]),s=JSON.parse('{"path":"/zh/algorithm/leetcode/backtracking/","title":"回溯","lang":"zh-CN","frontmatter":{"title":"回溯","icon":"discover","date":"2024-01-25T00:00:00.000Z","dir":{"order":8},"category":"leetcode","tag":"backtracking","sticky":false,"description":"回溯 回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径。 回溯是递归的副产品，只要有递归就会有回溯。 回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。 回溯法解决的问题可以概括如下： 组合问题：N个数⾥⾯按⼀定规则...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"回溯\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-02-20T13:11:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mike\\"}]}"],["meta",{"property":"og:url","content":"https://thecodedmike.github.io/zh/algorithm/leetcode/backtracking/"}],["meta",{"property":"og:site_name","content":"Mike的博客"}],["meta",{"property":"og:title","content":"回溯"}],["meta",{"property":"og:description","content":"回溯 回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径。 回溯是递归的副产品，只要有递归就会有回溯。 回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。 回溯法解决的问题可以概括如下： 组合问题：N个数⾥⾯按⼀定规则..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-02-20T13:11:45.000Z"}],["meta",{"property":"article:tag","content":"backtracking"}],["meta",{"property":"article:published_time","content":"2024-01-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-20T13:11:45.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://thecodedmike.github.io/algorithm/leetcode/backtracking/"}]]},"git":{"createdTime":1705928357000,"updatedTime":1708434705000,"contributors":[{"name":"mike","username":"mike","email":"lixiaofeng1115@outlook.com","commits":19,"url":"https://github.com/mike"}]},"readingTime":{"minutes":1.52,"words":457},"filePathRelative":"zh/algorithm/leetcode/backtracking/README.md","excerpt":"<h2>回溯</h2>\\n<p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就<strong>回溯</strong>返回，尝试别的路径。</p>\\n<p>回溯是递归的副产品，只要有递归就会有回溯。</p>\\n<p>回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>\\n<p>回溯法解决的问题可以概括如下：</p>\\n<ul>\\n<li>组合问题：N个数⾥⾯按⼀定规则找出k个数的集合</li>\\n<li>切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式</li>\\n<li>⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集</li>\\n<li>排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式</li>\\n<li>棋盘问题：N皇后，解数独等等</li>\\n</ul>","autoDesc":true}')}}]);