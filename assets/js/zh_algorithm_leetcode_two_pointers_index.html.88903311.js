"use strict";(self.webpackChunkmike_blog=self.webpackChunkmike_blog||[]).push([[69961],{1511:(e,t,l)=>{e.exports=l.p+"assets/img/two_pointers_in_array.bad5b61d.webp"},53998:(e,t,l)=>{e.exports=l.p+"assets/img/two_pointers_in_linkedlist.f1ffff32.png"},68524:(e,t,l)=>{l.r(t),l.d(t,{comp:()=>i,data:()=>h});var a=l(60362),r=l(1511),o=l(53998);const n={},i=(0,l(75726).A)(n,[["render",function(e,t){const l=(0,a.g2)("RouteLink");return(0,a.uX)(),(0,a.CE)("div",null,[t[22]||(t[22]=(0,a.Fv)('<h2 id="双指针" tabindex="-1"><a class="header-anchor" href="#双指针"><span>双指针</span></a></h2><p>双指针技术是一种以受控的方式遍历数据集（通常是数组或列表）的技术。它包括两个指针，一个指向数据集的开头，另一个指向数据集的结尾，并根据特定条件将它们相互移动。这种技术通常用于解决涉及在数据集中搜索特定条件或模式的问题，或者需要对数据集中的不同元素进行比较的问题。</p><p>双指针技术主要用于解决具有线性时间复杂度的问题，与暴力解法相比，它可以大大提高性能。使用该技术解决的一些常见问题包括：</p><ul><li>查找一组数据中的最大/最小值。</li><li>计算特定元素的出现次数。</li><li>查找没有重复字符的最长子串。</li><li>查找大小为<code>k</code>的子数组的最大和。</li></ul><p>总的来说，双指针技术是解决特定类型问题的有用方法，这些问题涉及以可控方式迭代数据集，如模式匹配、数据分析和统计。它可以对数据集进行高效、可控的迭代，从而提高性能和结果的准确性。</p><p><img src="'+r+'" alt="two pointers" loading="lazy"><br><img src="'+o+'" alt="two pointers" loading="lazy"></p><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题"><span>习题</span></a></h2><h3 id="移除元素" tabindex="-1"><a class="header-anchor" href="#移除元素"><span>移除元素</span></a></h3>',8)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/array/27_remove_element.html"},{default:(0,a.k6)(()=>[...t[0]||(t[0]=[(0,a.eW)("27: 移除元素",-1)])]),_:1}),t[5]||(t[5]=(0,a.Lk)("br",null,null,-1)),(0,a.bF)(l,{to:"/zh/algorithm/leetcode/array/26_remove_duplicates_from_sorted_array.html"},{default:(0,a.k6)(()=>[...t[1]||(t[1]=[(0,a.eW)("26: 删除有序数组中的重复项",-1)])]),_:1}),t[6]||(t[6]=(0,a.Lk)("br",null,null,-1)),(0,a.bF)(l,{to:"/zh/algorithm/leetcode/array/283_move_zeroes.html"},{default:(0,a.k6)(()=>[...t[2]||(t[2]=[(0,a.eW)("283: 移动零",-1)])]),_:1}),t[7]||(t[7]=(0,a.Lk)("br",null,null,-1)),(0,a.bF)(l,{to:"/zh/algorithm/leetcode/array/844_backspace_string_compare.html"},{default:(0,a.k6)(()=>[...t[3]||(t[3]=[(0,a.eW)("844: 比较含退格的字符串",-1)])]),_:1}),t[8]||(t[8]=(0,a.Lk)("br",null,null,-1)),(0,a.bF)(l,{to:"/zh/algorithm/leetcode/array/977_squares_of_a_sorted_array.html"},{default:(0,a.k6)(()=>[...t[4]||(t[4]=[(0,a.eW)("977: 有序数组的平方",-1)])]),_:1})]),t[23]||(t[23]=(0,a.Lk)("h3",{id:"反转字符串",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#反转字符串"},[(0,a.Lk)("span",null,"反转字符串")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/string/344_reverse_string.html"},{default:(0,a.k6)(()=>[...t[9]||(t[9]=[(0,a.eW)("344: 反转字符串",-1)])]),_:1})]),t[24]||(t[24]=(0,a.Lk)("h3",{id:"替换数字",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#替换数字"},[(0,a.Lk)("span",null,"替换数字")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/string/kamacoder_54_replace_numbers.html"},{default:(0,a.k6)(()=>[...t[10]||(t[10]=[(0,a.eW)("卡码网54: 替换数字",-1)])]),_:1})]),t[25]||(t[25]=(0,a.Lk)("h3",{id:"翻转字符串里的单词",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#翻转字符串里的单词"},[(0,a.Lk)("span",null,"翻转字符串里的单词")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/string/151_reverse_words_in_a_string.html"},{default:(0,a.k6)(()=>[...t[11]||(t[11]=[(0,a.eW)("151: 翻转字符串里的单词",-1)])]),_:1})]),t[26]||(t[26]=(0,a.Lk)("h3",{id:"反转链表",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#反转链表"},[(0,a.Lk)("span",null,"反转链表")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/linkedlist/206_reverse_linked_list.html"},{default:(0,a.k6)(()=>[...t[12]||(t[12]=[(0,a.eW)("206: 反转链表",-1)])]),_:1})]),t[27]||(t[27]=(0,a.Lk)("h3",{id:"删除链表的倒数第n个节点",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#删除链表的倒数第n个节点"},[(0,a.Lk)("span",null,"删除链表的倒数第N个节点")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/linkedlist/19_remove_nth_node_from_end_of_list.html"},{default:(0,a.k6)(()=>[...t[13]||(t[13]=[(0,a.eW)("19: 删除链表的倒数第N个节点",-1)])]),_:1})]),t[28]||(t[28]=(0,a.Lk)("h3",{id:"链表相交",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#链表相交"},[(0,a.Lk)("span",null,"链表相交")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/linkedlist/160_intersection_of_two_linked_lists.html"},{default:(0,a.k6)(()=>[...t[14]||(t[14]=[(0,a.eW)("160: 链表相交",-1)])]),_:1})]),t[29]||(t[29]=(0,a.Lk)("h3",{id:"环形链表",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#环形链表"},[(0,a.Lk)("span",null,"环形链表")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/linkedlist/141_linked_list_cycle.html"},{default:(0,a.k6)(()=>[...t[15]||(t[15]=[(0,a.eW)("141: 环形链表",-1)])]),_:1}),t[17]||(t[17]=(0,a.Lk)("br",null,null,-1)),(0,a.bF)(l,{to:"/zh/algorithm/leetcode/linkedlist/142_linked_list_cycle_II.html"},{default:(0,a.k6)(()=>[...t[16]||(t[16]=[(0,a.eW)("142: 环形链表II",-1)])]),_:1})]),t[30]||(t[30]=(0,a.Lk)("h3",{id:"三数之和",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#三数之和"},[(0,a.Lk)("span",null,"三数之和")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/hashtable/15_three_sum.html"},{default:(0,a.k6)(()=>[...t[18]||(t[18]=[(0,a.eW)("15: 三数之和",-1)])]),_:1}),t[20]||(t[20]=(0,a.Lk)("br",null,null,-1)),(0,a.bF)(l,{to:"/zh/algorithm/leetcode/hashtable/16_three_sum_closest.html"},{default:(0,a.k6)(()=>[...t[19]||(t[19]=[(0,a.eW)("16: 最接近的三数之和",-1)])]),_:1})]),t[31]||(t[31]=(0,a.Lk)("h3",{id:"四数之和",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#四数之和"},[(0,a.Lk)("span",null,"四数之和")])],-1)),(0,a.Lk)("p",null,[(0,a.bF)(l,{to:"/zh/algorithm/leetcode/hashtable/18_four_sum.html"},{default:(0,a.k6)(()=>[...t[21]||(t[21]=[(0,a.eW)("18: 四数之和",-1)])]),_:1})]),t[32]||(t[32]=(0,a.Lk)("h2",{id:"总结",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#总结"},[(0,a.Lk)("span",null,"总结")])],-1))])}]]),h=JSON.parse('{"path":"/zh/algorithm/leetcode/two_pointers/","title":"双指针","lang":"zh-CN","frontmatter":{"title":"双指针","icon":"discover","date":"2023-11-25T00:00:00.000Z","dir":{"order":5},"category":"leetcode","tag":"two pointers","sticky":false,"description":"双指针 双指针技术是一种以受控的方式遍历数据集（通常是数组或列表）的技术。它包括两个指针，一个指向数据集的开头，另一个指向数据集的结尾，并根据特定条件将它们相互移动。这种技术通常用于解决涉及在数据集中搜索特定条件或模式的问题，或者需要对数据集中的不同元素进行比较的问题。 双指针技术主要用于解决具有线性时间复杂度的问题，与暴力解法相比，它可以大大提高性能...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"双指针\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-11-25T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-25T17:34:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mike\\"}]}"],["meta",{"property":"og:url","content":"https://thecodedmike.github.io/zh/algorithm/leetcode/two_pointers/"}],["meta",{"property":"og:site_name","content":"Mike的博客"}],["meta",{"property":"og:title","content":"双指针"}],["meta",{"property":"og:description","content":"双指针 双指针技术是一种以受控的方式遍历数据集（通常是数组或列表）的技术。它包括两个指针，一个指向数据集的开头，另一个指向数据集的结尾，并根据特定条件将它们相互移动。这种技术通常用于解决涉及在数据集中搜索特定条件或模式的问题，或者需要对数据集中的不同元素进行比较的问题。 双指针技术主要用于解决具有线性时间复杂度的问题，与暴力解法相比，它可以大大提高性能..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-11-25T17:34:26.000Z"}],["meta",{"property":"article:tag","content":"two pointers"}],["meta",{"property":"article:published_time","content":"2023-11-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-25T17:34:26.000Z"}],["link",{"rel":"alternate","hreflang":"en-us","href":"https://thecodedmike.github.io/algorithm/leetcode/two_pointers/"}]]},"git":{"createdTime":1700933666000,"updatedTime":1700933666000,"contributors":[{"name":"mike","username":"mike","email":"lixiaofeng1115@outlook.com","commits":1,"url":"https://github.com/mike"}]},"readingTime":{"minutes":1.76,"words":528},"filePathRelative":"zh/algorithm/leetcode/two_pointers/README.md","excerpt":"<h2>双指针</h2>\\n<p>双指针技术是一种以受控的方式遍历数据集（通常是数组或列表）的技术。它包括两个指针，一个指向数据集的开头，另一个指向数据集的结尾，并根据特定条件将它们相互移动。这种技术通常用于解决涉及在数据集中搜索特定条件或模式的问题，或者需要对数据集中的不同元素进行比较的问题。</p>\\n<p>双指针技术主要用于解决具有线性时间复杂度的问题，与暴力解法相比，它可以大大提高性能。使用该技术解决的一些常见问题包括：</p>\\n<ul>\\n<li>查找一组数据中的最大/最小值。</li>\\n<li>计算特定元素的出现次数。</li>\\n<li>查找没有重复字符的最长子串。</li>\\n<li>查找大小为<code>k</code>的子数组的最大和。</li>\\n</ul>","autoDesc":true}')},75726:(e,t)=>{t.A=(e,t)=>{const l=e.__vccOpts||e;for(const[e,a]of t)l[e]=a;return l}}}]);