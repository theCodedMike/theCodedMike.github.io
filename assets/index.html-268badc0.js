import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as d,c as o,a as e,d as i,w as l,e as c,b as t}from"./app-f3510c46.js";const s={},h=c(`<h2 id="回溯" tabindex="-1"><a class="header-anchor" href="#回溯" aria-hidden="true">#</a> 回溯</h2><p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就<strong>回溯</strong>返回，尝试别的路径。</p><p>回溯是递归的副产品，只要有递归就会有回溯。</p><p>回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><p>回溯法解决的问题可以概括如下：</p><ul><li>组合问题：N个数⾥⾯按⼀定规则找出k个数的集合</li><li>切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式</li><li>⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集</li><li>排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯法解决的问题都可以抽象为树形结构。</p><p>回溯算法模板框架如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>void backtracking(参数) {
    if (终⽌条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中孩⼦节点的数量就是集合的⼤⼩）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果;
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="习题" tabindex="-1"><a class="header-anchor" href="#习题" aria-hidden="true">#</a> 习题</h2><h3 id="组合" tabindex="-1"><a class="header-anchor" href="#组合" aria-hidden="true">#</a> 组合</h3>`,11),_=e("br",null,null,-1),u=e("br",null,null,-1),m=e("br",null,null,-1),b=e("br",null,null,-1),k=e("h3",{id:"分割",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#分割","aria-hidden":"true"},"#"),t(" 分割")],-1),g=e("br",null,null,-1),f=e("h3",{id:"子集",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#子集","aria-hidden":"true"},"#"),t(" 子集")],-1),v=e("br",null,null,-1),p=e("h3",{id:"排列",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#排列","aria-hidden":"true"},"#"),t(" 排列")],-1),x=e("br",null,null,-1),z=e("h3",{id:"棋盘问题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#棋盘问题","aria-hidden":"true"},"#"),t(" 棋盘问题")],-1),I=e("br",null,null,-1),N=e("br",null,null,-1),V=e("br",null,null,-1),q=e("h3",{id:"其他",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#其他","aria-hidden":"true"},"#"),t(" 其他")],-1),B=e("br",null,null,-1),w=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),t(" 总结")],-1);function C(L,R){const a=r("RouterLink");return d(),o("div",null,[h,e("p",null,[i(a,{to:"/zh/algorithm/leetcode/backtracking/77_combinations.html"},{default:l(()=>[t("77: 组合")]),_:1}),_,i(a,{to:"/zh/algorithm/leetcode/backtracking/17_letter_combinations_of_a_phone_number.html"},{default:l(()=>[t("17: 电话号码的字母组合")]),_:1}),u,i(a,{to:"/zh/algorithm/leetcode/backtracking/39_combination_sum.html"},{default:l(()=>[t("39: 组合总和")]),_:1}),m,i(a,{to:"/zh/algorithm/leetcode/backtracking/40_combination_sum_ii.html"},{default:l(()=>[t("40: 组合总和II")]),_:1}),b,i(a,{to:"/zh/algorithm/leetcode/backtracking/216_combination_sum_iii.html"},{default:l(()=>[t("216: 组合总和III")]),_:1})]),k,e("p",null,[i(a,{to:"/zh/algorithm/leetcode/backtracking/131_palindrome_partitioning.html"},{default:l(()=>[t("131: 分割回文串")]),_:1}),g,i(a,{to:"/zh/algorithm/leetcode/backtracking/93_restore_ip_addresses.html"},{default:l(()=>[t("93: 复原IP地址")]),_:1})]),f,e("p",null,[i(a,{to:"/zh/algorithm/leetcode/backtracking/78_subsets.html"},{default:l(()=>[t("78: 子集")]),_:1}),v,i(a,{to:"/zh/algorithm/leetcode/backtracking/90_subsets_ii.html"},{default:l(()=>[t("90: 子集II")]),_:1})]),p,e("p",null,[i(a,{to:"/zh/algorithm/leetcode/backtracking/46_permutations.html"},{default:l(()=>[t("46: 全排列")]),_:1}),x,i(a,{to:"/zh/algorithm/leetcode/backtracking/47_permutations_ii.html"},{default:l(()=>[t("47: 全排列II")]),_:1})]),z,e("p",null,[i(a,{to:"/zh/algorithm/leetcode/backtracking/51_n_queens.html"},{default:l(()=>[t("51: N皇后")]),_:1}),I,i(a,{to:"/zh/algorithm/leetcode/backtracking/52_n_queens_ii.html"},{default:l(()=>[t("52: N皇后II")]),_:1}),N,i(a,{to:"/zh/algorithm/leetcode/backtracking/36_valid_sudoku.html"},{default:l(()=>[t("36: 有效的数独")]),_:1}),V,i(a,{to:"/zh/algorithm/leetcode/backtracking/37_sudoku_solver.html"},{default:l(()=>[t("37: 解数独")]),_:1})]),q,e("p",null,[i(a,{to:"/zh/algorithm/leetcode/backtracking/491_non_decreasing_subsequences.html"},{default:l(()=>[t("491: 递增子序列")]),_:1}),B,i(a,{to:"/zh/algorithm/leetcode/backtracking/332_reconstruct_itinerary.html"},{default:l(()=>[t("332: 重新安排行程")]),_:1})]),w])}const P=n(s,[["render",C],["__file","index.html.vue"]]);export{P as default};
