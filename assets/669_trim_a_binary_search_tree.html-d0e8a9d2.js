const e=JSON.parse('{"key":"v-705f71f2","path":"/zh/algorithm/leetcode/binary_tree/669_trim_a_binary_search_tree.html","title":"669, 修剪二叉搜索树","lang":"zh-CN","frontmatter":{"title":"669, 修剪二叉搜索树","icon":"discover","date":"2024-01-18T00:00:00.000Z","order":36,"sticky":true,"category":"binary tree","tag":["medium","binary tree","binary search tree","depth first search"],"description":"一、题目描述 给你二叉搜索树的根节点root，同时给定最小边界low和最大边界high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在唯一的答案。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 1 输入: root = [1, 0, 2], low = 1, high = 2 输出: [1, null, 2]","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://thecodedmike.github.io/algorithm/leetcode/binary_tree/669_trim_a_binary_search_tree.html"}],["meta",{"property":"og:url","content":"https://thecodedmike.github.io/zh/algorithm/leetcode/binary_tree/669_trim_a_binary_search_tree.html"}],["meta",{"property":"og:site_name","content":"Mike的博客"}],["meta",{"property":"og:title","content":"669, 修剪二叉搜索树"}],["meta",{"property":"og:description","content":"一、题目描述 给你二叉搜索树的根节点root，同时给定最小边界low和最大边界high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在唯一的答案。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 1 输入: root = [1, 0, 2], low = 1, high = 2 输出: [1, null, 2]"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-01-18T13:15:38.000Z"}],["meta",{"property":"article:author","content":"Mike"}],["meta",{"property":"article:tag","content":"medium"}],["meta",{"property":"article:tag","content":"binary tree"}],["meta",{"property":"article:tag","content":"binary search tree"}],["meta",{"property":"article:tag","content":"depth first search"}],["meta",{"property":"article:published_time","content":"2024-01-18T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-18T13:15:38.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"669, 修剪二叉搜索树\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-18T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-18T13:15:38.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mike\\"}]}"]]},"headers":[{"level":2,"title":"一、题目描述","slug":"一、题目描述","link":"#一、题目描述","children":[]},{"level":2,"title":"二、题解","slug":"二、题解","link":"#二、题解","children":[{"level":3,"title":"方法 1: 递归","slug":"方法-1-递归","link":"#方法-1-递归","children":[]},{"level":3,"title":"方法 2: 迭代","slug":"方法-2-迭代","link":"#方法-2-迭代","children":[]}]}],"git":{"createdTime":1705583738000,"updatedTime":1705583738000,"contributors":[{"name":"mike","email":"lixiaofeng1115@outlook.com","commits":1}]},"readingTime":{"minutes":2.48,"words":745},"filePathRelative":"zh/algorithm/leetcode/binary_tree/669_trim_a_binary_search_tree.md","localizedDate":"2024年1月18日","excerpt":"<h2> 一、题目描述</h2>\\n<p>给你二叉搜索树的根节点<code>root</code>，同时给定最小边界<code>low</code>和最大边界<code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树<strong>不应该</strong>改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在<strong>唯一的答案</strong>。</p>\\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\\n<p><strong>示例 1</strong><br>\\n<br>\\n输入: root = [1, 0, 2], low = 1, high = 2<br>\\n输出: [1, null, 2]</p>","autoDesc":true}');export{e as data};
