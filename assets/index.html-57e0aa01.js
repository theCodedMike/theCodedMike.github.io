const e=JSON.parse('{"key":"v-3575b942","path":"/zh/algorithm/leetcode/backtracking/","title":"回溯","lang":"zh-CN","frontmatter":{"title":"回溯","icon":"discover","date":"2024-01-25T00:00:00.000Z","dir":{"order":8},"category":"leetcode","tag":"backtracking","sticky":false,"description":"回溯 回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径。 回溯是递归的副产品，只要有递归就会有回溯。 回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。 回溯法解决的问题可以概括如下： 组合问题：N个数⾥⾯按⼀定规则找出k个数的集合 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式 ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集 排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式 棋盘问题：N皇后，解数独等等","head":[["link",{"rel":"alternate","hreflang":"en-us","href":"https://thecodedmike.github.io/algorithm/leetcode/backtracking/"}],["meta",{"property":"og:url","content":"https://thecodedmike.github.io/zh/algorithm/leetcode/backtracking/"}],["meta",{"property":"og:site_name","content":"Mike的博客"}],["meta",{"property":"og:title","content":"回溯"}],["meta",{"property":"og:description","content":"回溯 回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径。 回溯是递归的副产品，只要有递归就会有回溯。 回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。 回溯法解决的问题可以概括如下： 组合问题：N个数⾥⾯按⼀定规则找出k个数的集合 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式 ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集 排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式 棋盘问题：N皇后，解数独等等"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:locale:alternate","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2024-01-26T13:32:54.000Z"}],["meta",{"property":"article:author","content":"Mike"}],["meta",{"property":"article:tag","content":"backtracking"}],["meta",{"property":"article:published_time","content":"2024-01-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-26T13:32:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"回溯\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-01-25T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-26T13:32:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mike\\"}]}"]]},"headers":[{"level":2,"title":"回溯","slug":"回溯","link":"#回溯","children":[]},{"level":2,"title":"习题","slug":"习题","link":"#习题","children":[{"level":3,"title":"组合","slug":"组合","link":"#组合","children":[]},{"level":3,"title":"分割","slug":"分割","link":"#分割","children":[]},{"level":3,"title":"子集","slug":"子集","link":"#子集","children":[]},{"level":3,"title":"排列","slug":"排列","link":"#排列","children":[]},{"level":3,"title":"棋盘问题","slug":"棋盘问题","link":"#棋盘问题","children":[]},{"level":3,"title":"其他","slug":"其他","link":"#其他","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1705928357000,"updatedTime":1706275974000,"contributors":[{"name":"mike","email":"lixiaofeng1115@outlook.com","commits":3}]},"readingTime":{"minutes":1.45,"words":435},"filePathRelative":"zh/algorithm/leetcode/backtracking/README.md","localizedDate":"2024年1月25日","excerpt":"<h2> 回溯</h2>\\n<p>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就<strong>回溯</strong>返回，尝试别的路径。</p>\\n<p>回溯是递归的副产品，只要有递归就会有回溯。</p>\\n<p>回溯法并不是什么⾼效的算法，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>\\n<p>回溯法解决的问题可以概括如下：</p>\\n<ul>\\n<li>组合问题：N个数⾥⾯按⼀定规则找出k个数的集合</li>\\n<li>切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式</li>\\n<li>⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集</li>\\n<li>排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式</li>\\n<li>棋盘问题：N皇后，解数独等等</li>\\n</ul>","autoDesc":true}');export{e as data};
